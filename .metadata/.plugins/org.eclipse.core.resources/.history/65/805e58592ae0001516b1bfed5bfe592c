/**
 * @author Dilshad Mustafa
 * (c) Dilshad Mustafa
 * All Rights Reserved.
 * @version 1.0
 * @since 29-Feb-2016
 * File Name : DComputeAsyncRun.java
 */
package com.dilmus.dilshad.scabi.client.async;

import java.io.IOException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.apache.http.ParseException;
import org.apache.http.ProtocolException;
import org.apache.http.client.ClientProtocolException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dilmus.dilshad.scabi.common.DMJson;
import com.dilmus.dilshad.scabi.common.DScabiException;
import org.apache.http.HttpResponse;

/**
 * @author Dilshad Mustafa
 *
 */
public class DComputeAsyncRun implements Runnable {

	private final Logger log = LoggerFactory.getLogger(DComputeAsyncRun.class);
	private DComputeAsyncConfig m_config = null;
	private DComputeNoBlock m_computeNB = null;
	private boolean m_isDone = false;
	private boolean m_isError = false;
	private boolean m_isRetrySubmitted = false;
	private boolean m_isRunOnce = false;
	
	private boolean m_isExecutionError = false;
	
	private int m_TU = 0;
	private int m_SU = 0;
	private int m_retriesTillNow = 0;
	private int m_maxRetry = 0;
	
	private Future<HttpResponse> m_futureHttpResponse = null;
	
	public DComputeAsyncRun() {
		m_config = null;
		m_computeNB = null;

		m_isDone = false;
		m_isError = false;
		m_isRetrySubmitted = false;
		m_isRunOnce = false;
		
		m_isExecutionError = false;
		
		m_futureHttpResponse = null;
	}
	
	public int setTU(int totalUnits) {
		m_TU = totalUnits;
		return 0;
	}

	public int setSU(int splitno) {
		m_SU = splitno;
		return 0;
	}
	
	public int setMaxRetry(int maxRetry) {
		m_maxRetry = maxRetry;
		return 0;
	}

	public int getTU() {
		return m_TU;
	}

	public int getSU() {
		return m_SU;
	}
	
	public int getMaxRetry() {
		return m_maxRetry;
	}
	
	public int getRetriesTillNow() {
		return m_retriesTillNow;
	}

	public Future<HttpResponse> getFutureHttpResponse() {
		return m_futureHttpResponse;
	}
	
	public boolean isError() {
		return m_isError;
	}
	
	public boolean isDone() {
		return m_isDone;
	}

	public boolean isRunOnce() {
		return m_isRunOnce;
	}
	
	public int setComputeNB(DComputeNoBlock computeNB) {
		// TODO check if we need to do this m_futureHttpResponse = null;
		m_computeNB = computeNB;
		return 0;
	}
	
	public DComputeNoBlock getComputeNB() {
		return m_computeNB;
	}

	public int setConfig(DComputeAsyncConfig config) {
		m_config = config;
		return 0;
	}
	
	public DComputeAsyncConfig getConfig() {
		return m_config;
	}
	
	public int setRetrySubmitStatus(boolean status) {
		m_isRetrySubmitted = status;
		return 0;
	}
	
	public boolean isRetrySubmitted() {
		return m_isRetrySubmitted;
	}
	
	public int setExecutionError(String errorMessage) {
		m_isExecutionError = true;
		synchronized (m_config) {
			m_config.setResult(m_SU, errorMessage);
		}
		return 0;
	}
	
	public boolean isExecutionError() {
		return m_isExecutionError;
	}
	
	public int setFlags() {
		m_isDone = true;
		if (true == m_isError)
			m_retriesTillNow = m_retriesTillNow + 1;
		m_isError = false;
		m_isRetrySubmitted = false;
		if (false == m_isRunOnce) {
			m_isRunOnce = true;
		}
		return 0;
	}
	
	public void doRun() throws IOException, DScabiException {
		
		if (null == m_config) {
			// Not used throw new DScabiException("config is not set", "CRN.RUN.1");
			log.debug("doRun() config is not set");
			return;
		}
		if (null == m_computeNB) {
			// Not used throw new DScabiException("computeSync is not set", "CRN.RUN.1");
			log.debug("doRun() computeSync is not set");
			return;
		}
		
		int splitno = m_SU;
		log.debug("doRun() splitno : {}", splitno);
		m_futureHttpResponse = null;
		try {
			if (DComputeAsyncConfig.OBJECT == m_config.getConfigType()) {
				log.debug("doRun() Executing for Object");
				m_futureHttpResponse = m_computeNB.executeObject(m_config.getComputeUnit());
				
			} else if (DComputeAsyncConfig.CLASS == m_config.getConfigType()){
				log.debug("doRun() Executing for Class");
				m_futureHttpResponse = m_computeNB.executeClass(m_config.getComputeClass());
				
				
			} else if (DComputeAsyncConfig.CODE == m_config.getConfigType()){
				log.debug("doRun() Executing for Code");
				m_futureHttpResponse = m_computeNB.executeCode(m_config.getComputeCode());
				
			} else {
				throw new DScabiException("Unknown ComputeConfig type m_config.getConfigType() " + m_config.getConfigType(), "CRN.DRN.1");
			}
					
		} catch (ClientProtocolException e) {
			log.debug("doRun() Exception : {}", e.toString());
			// m_computeNB is faulty only in the case of ClientProtocolException/NetworkException
			m_computeNB.setFaulty(true);
			String errorJson = DMJson.error(e.toString());
			synchronized (m_config) {
				m_config.setResult(splitno, errorJson);
			}
			// m_isError is set only in the case of network exception
			// only in this case retry has to be attempted if maxRetry > 0 is set by User
			m_isError = true; 
		}
		
	}

	public void run() {
		m_isDone = false;
		if (true == m_isError)
			m_retriesTillNow = m_retriesTillNow + 1;
		m_isError = false;
		synchronized (m_computeNB) {
			try {
				m_computeNB.setTU(m_TU);
				m_computeNB.setSU(m_SU);

		        doRun();
		    } catch (Throwable e) {
				log.debug("run() Throwable : {}", e.toString());
				// m_computeNB is faulty only in the case of ClientProtocolException/NetworkException which 
				// is already handled in doRun() method
				// // // m_computeNB.setFaulty(true);
				
				// TODO: check later, low priority, whether to use m_SU
				int splitno = m_computeNB.getSU(); // just to be exact, getting SU directly from m_computeNB
				log.debug("run() m_computeNB.getSU() : {}", splitno);
				String errorJson = DMJson.error(e.toString());
				synchronized (m_config) {
					m_config.setResult(splitno, errorJson);
				}
	        	
		    }
			
		}
		m_isDone = true;
		m_isRetrySubmitted = false;
		if (false == m_isRunOnce) {
			m_isRunOnce = true;
		}
	}
	
}
