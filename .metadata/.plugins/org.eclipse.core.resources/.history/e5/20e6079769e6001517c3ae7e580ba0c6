/**
 * @author Dilshad Mustafa
 * (c) Dilshad Mustafa
 * All Rights Reserved.
 * @version 1.0
 * @since 27-Jan-2016
 * File Name : Meta.java
 */
package com.dilmus.dilshad.scabi.client;

import java.io.IOException;
import java.util.List;
import java.util.Set;

import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.ParseException;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dilmus.dilshad.scabi.client.DScabiClientException;
import com.dilmus.dilshad.scabi.client.async.DComputeNoBlock;
import com.dilmus.dilshad.scabi.common.DMJson;
import com.dilmus.dilshad.scabi.common.DMJsonHelper;
import com.dilmus.dilshad.scabi.common.DScabiException;

/**
 * @author Dilshad Mustafa
 *
 */
public class DMeta {

	private final Logger log = LoggerFactory.getLogger(DMeta.class);
	private CloseableHttpClient m_httpClient = null;
	private HttpHost m_target = null;
	private String m_host = null;
	private String m_port = null;
	private boolean m_firstTime = true;
	
	public DMeta(String host, String port) throws IOException {
		m_host = host;
		m_port = port;
		m_firstTime = true;
	}
	
	public boolean validate() throws IOException, DScabiClientException {
		boolean status = false;
		try {
			m_httpClient = HttpClientBuilder.create().build();
			m_target = new HttpHost(m_host, Integer.parseInt(m_port), "http");
    		status = true;
    	} catch (Exception e) {
			e.printStackTrace();
			status = false;
    		if (null != m_httpClient) { 
    			m_httpClient.close();
    			m_httpClient = null;
    		}
    		throw e;
		}
	
		HttpPost postRequest = new HttpPost("/Meta/Validate");
		String myString = "";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("validate() executing request to " + m_target + "/Meta/Validate");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("validate()----------------------------------------");
		log.debug("validate() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("validate {}", headers[i]);
		}
		log.debug("validate()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("validate() {}", jsonString);
		}
		if (null == jsonString) {
			status = false;
			throw new DScabiClientException("Response is null for validate()", "MEA.VAE.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			status = false;
			throw new DScabiClientException("Unable to validate. Error message : " + jsonString, "MEA.VAE.2");
		}
		if (false == DMJsonHelper.isOk(jsonString))
			status = false;
		else
			status = true;
		if (null != m_httpClient) { 
			m_httpClient.close();
			m_httpClient = null;
		}
		
		return status;
	}

	public boolean open() throws IOException {
		if (false == m_firstTime)
			return true;
		boolean status = false;
		try {
			m_httpClient = HttpClientBuilder.create().build();
			m_target = new HttpHost(m_host, Integer.parseInt(m_port), "http");
    		status = true;
    		m_firstTime = false;
    	} catch (Exception e) {
			e.printStackTrace();
			status = false;
    		if (null != m_httpClient) { 
    			m_httpClient.close();
    			m_httpClient = null;
    		}
    		throw e;
    	}
		return status;
	}
	
	public boolean close() throws IOException {
		if (null != m_httpClient) 
			m_httpClient.close();

		m_httpClient = null;
		m_target = null;
		m_firstTime = true;
		return true;
	}
	
	public String getHost() {
		return m_host;
	}
	
	public String getPort() {
		return m_port;
	}
	
	public DComputeSync computeAlloc() throws ParseException, IOException, DScabiClientException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Compute/Alloc");
		String myString = "";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("computeAlloc() executing request to " + m_target + "/Meta/Compute/Alloc");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("computeAlloc()----------------------------------------");
		log.debug("computeAlloc() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("computeAlloc() {}", headers[i]);
		}
		log.debug("computeAlloc()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("computeAlloc() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for computeAlloc()", "MEA.CAC.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to alloc compute unit. Error message : " + jsonString, "MEA.CAC.2");
		}
		return new DComputeSync(jsonString);
	}

	public DComputeSync getCompute() throws ParseException, IOException, DScabiClientException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Compute/GetOne");
		String myString = "";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("computeAlloc() executing request to " + m_target + "/Meta/Compute/GetOne");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("computeAlloc()----------------------------------------");
		log.debug("computeAlloc() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("computeAlloc() {}", headers[i]);
		}
		log.debug("computeAlloc()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("computeAlloc() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for computeAlloc()", "MEA.CAC.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to alloc compute unit. Error message : " + jsonString, "MEA.CAC.2");
		}
		return new DComputeSync(jsonString);
	}

	public DComputeSync[] getComputeManyMayExclude(int howMany, List<DComputeSync> exclude) throws ParseException, IOException, DScabiClientException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Compute/GetMany");
		String myString = "{ \"GetComputeMany\" : \"" + howMany + "\" }";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("getComputeMany() executing request to " + m_target + "/Meta/Compute/GetMany");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("getComputeMany()----------------------------------------");
		log.debug("getComputeMany() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("getComputeMany() {}", headers[i]);
		}
		log.debug("getComputeMany()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("getComputeMany() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for getCompute(int howmany)", "MEA.CAC.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to get compute unit. Error message : " + jsonString, "MEA.CAC.2");
		}
		DMJson djson = new DMJson(jsonString);
		int count = djson.getCount();
		Set<String> st = djson.keySet();
		// st.remove("Count"); // UnsupportedOperationException, Unmodifiable
		DComputeSync csa[] = new DComputeSync[count];
		int i = 0;
		for (String s : st) {
			if (s.equals("Count"))
				continue;
			csa[i] = new DComputeSync(djson.getString(s));
			i++;
		}
		
		return csa;
	}
	
	public DComputeSync[] getComputeMany(int howMany) throws ParseException, IOException, DScabiClientException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Compute/GetMany");
		String myString = "{ \"GetComputeMany\" : \"" + howMany + "\" }";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("getComputeMany() executing request to " + m_target + "/Meta/Compute/GetMany");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("getComputeMany()----------------------------------------");
		log.debug("getComputeMany() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("getComputeMany() {}", headers[i]);
		}
		log.debug("getComputeMany()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("getComputeMany() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for getCompute(int howmany)", "MEA.CAC.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to get compute unit. Error message : " + jsonString, "MEA.CAC.2");
		}
		DMJson djson = new DMJson(jsonString);
		int count = djson.getCount();
		Set<String> st = djson.keySet();
		// st.remove("Count"); // UnsupportedOperationException, Unmodifiable
		DComputeSync csa[] = new DComputeSync[count];
		int i = 0;
		for (String s : st) {
			if (s.equals("Count"))
				continue;
			csa[i] = new DComputeSync(djson.getString(s));
			i++;
		}
		
		return csa;
	}
	
	public DComputeNoBlock[] getComputeNoBlockMany(int howMany) throws ParseException, IOException, DScabiClientException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Compute/GetMany");
		String myString = "{ \"GetComputeMany\" : \"" + howMany + "\" }";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("getComputeMany() executing request to " + m_target + "/Meta/Compute/GetMany");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("getComputeMany()----------------------------------------");
		log.debug("getComputeMany() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("getComputeMany() {}", headers[i]);
		}
		log.debug("getComputeMany()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("getComputeMany() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for getCompute(int howmany)", "MEA.CAC.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to get compute unit. Error message : " + jsonString, "MEA.CAC.2");
		}
		DMJson djson = new DMJson(jsonString);
		int count = djson.getCount();
		Set<String> st = djson.keySet();
		// st.remove("Count"); // UnsupportedOperationException, Unmodifiable
		DComputeNoBlock csa[] = new DComputeNoBlock[count];
		int i = 0;
		for (String s : st) {
			if (s.equals("Count"))
				continue;
			csa[i] = new DComputeNoBlock(djson.getString(s));
			i++;
		}
		
		return csa;
	}

	public DComputeNoBlock[] getComputeNoBlockManyMayExclude(int howMany, List<DComputeNoBlock> exclude) throws ParseException, IOException, DScabiClientException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Compute/GetMany");
		String myString = "{ \"GetComputeMany\" : \"" + howMany + "\" }";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("getComputeMany() executing request to " + m_target + "/Meta/Compute/GetMany");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("getComputeMany()----------------------------------------");
		log.debug("getComputeMany() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("getComputeMany() {}", headers[i]);
		}
		log.debug("getComputeMany()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("getComputeMany() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for getCompute(int howmany)", "MEA.CAC.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to get compute unit. Error message : " + jsonString, "MEA.CAC.2");
		}
		DMJson djson = new DMJson(jsonString);
		int count = djson.getCount();
		Set<String> st = djson.keySet();
		// st.remove("Count"); // UnsupportedOperationException, Unmodifiable
		DComputeNoBlock csa[] = new DComputeNoBlock[count];
		int i = 0;
		for (String s : st) {
			if (s.equals("Count"))
				continue;
			csa[i] = new DComputeNoBlock(djson.getString(s));
			i++;
		}
		
		return csa;
	}

	public DNamespace getNamespace(String strNamespace) throws ParseException, IOException, DScabiClientException, DScabiException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Namespace/Get");
		String myString = "{ \"Namespace\" : \"" + strNamespace + "\" }";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("getNamespace() executing request to " + m_target + "/Meta/Namespace/Get");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("getNamespace()----------------------------------------");
		log.debug("getNamespace() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("getNamespace() {}", headers[i]);
		}
		log.debug("getNamespace()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("getNamespace() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for namespace " + strNamespace, "MEA.GNE.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to get namespace " + strNamespace + " Error message : " + jsonString, "MEA.GNE.2");
		}
		DNamespace namespace = new DNamespace(jsonString);
		return namespace;
		
	}

	public DNamespace getNamespace(String strNamespace) throws ParseException, IOException, DScabiClientException, DScabiException {

		
	}
	
	private DNamespace findOneNamespace(String metaType) throws ParseException, IOException, DScabiClientException, DScabiException {
		open();
		HttpPost postRequest = new HttpPost("/Meta/Namespace/FindOne");
		String myString = "{ \"Type\" : \"" +  metaType + "\" }";
	    StringEntity params =new StringEntity(myString);
	    
	    postRequest.addHeader("content-type", "application/json");
	    postRequest.setEntity(params);
	            			
		log.debug("findOneNamespace() executing request to " + m_target + "/Meta/Namespace/FindOne");

		// works HttpResponse httpResponse = httpClient.execute(target, getRequest);
		HttpResponse httpResponse = m_httpClient.execute(m_target, postRequest);
		HttpEntity entity = httpResponse.getEntity();
	
		log.debug("findOneNamespace()----------------------------------------");
		log.debug("findOneNamespace() {}",httpResponse.getStatusLine());
		Header[] headers = httpResponse.getAllHeaders();
		for (int i = 0; i < headers.length; i++) {
			log.debug("findOneNamespace() {}", headers[i]);
		}
		log.debug("findOneNamespace()----------------------------------------");

		String jsonString = null;
		if (entity != null) {
			jsonString = EntityUtils.toString(entity);
			log.debug("findOneNamespace() {}", jsonString);
		}
		if (null == jsonString) {
			throw new DScabiClientException("Response is null for Meta Type : " + metaType, "MEA.FON.1");
		}
		if (DMJsonHelper.isError(jsonString)) {
			throw new DScabiClientException("Unable to get namespace. Meta Type : " + metaType + " Error message : " + jsonString, "MEA.FON.2");
		}
		DNamespace namespace = new DNamespace(jsonString);
		return namespace;
		
	}

	public DNamespace findOneMetaThisNS() throws ParseException, IOException, DScabiClientException, DScabiException {
		return findOneNamespace("MetaThis");
	}
	
	public DNamespace findOneMetaRemoteNS() throws ParseException, IOException, DScabiClientException, DScabiException {
		return findOneNamespace("MetaRemote");
	}

	public DNamespace findOneAppTableNS() throws ParseException, IOException, DScabiClientException, DScabiException {
		return findOneNamespace("AppTable");
	}
	
	public DNamespace findOneJavaFileNS() throws ParseException, IOException, DScabiClientException, DScabiException {
		return findOneNamespace("JavaFile");
	}
	
	public DNamespace findOneFileNS() throws ParseException, IOException, DScabiClientException, DScabiException {
		return findOneNamespace("File");
	}
	
}
