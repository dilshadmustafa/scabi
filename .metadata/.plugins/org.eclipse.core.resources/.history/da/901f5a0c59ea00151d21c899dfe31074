/**
 * @author Dilshad Mustafa
 * (c) Dilshad Mustafa
 * All Rights Reserved.
 * @version 1.0
 * @since 28-Jan-2016
 * File Name : DDAO.java
 */
package com.dilmus.dilshad.scabi.deprecated;

import java.io.IOException;
import java.util.ArrayList;

import org.apache.http.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dilmus.dilshad.scabi.client.DMeta;
import com.dilmus.dilshad.scabi.client.DNamespace;
import com.dilmus.dilshad.scabi.client.DScabiClientException;
import com.dilmus.dilshad.scabi.common.DMJson;
import com.dilmus.dilshad.scabi.common.DScabiException;
import com.dilmus.dilshad.scabi.common.DTable;
import com.dilmus.dilshad.scabi.db.DDB;
import com.dilmus.dilshad.scabi.db.DResultSet;

/**
 * @author Dilshad Mustafa
 *
 */
public class Dao2 {

	final static Logger log = LoggerFactory.getLogger(Dao2.class);
	private String m_tableName = null;
	private boolean m_firstTime = true;
	private ArrayList<String> m_fieldNames = null;
	
	private DDB m_ddb = null;
	private DTable m_table = null;
	private DNamespace m_namespace = null;
	
	public Dao2(DDB ddb) {
		m_ddb = ddb;
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		m_namespace = null;
	}
	
	public Dao2(String dbHost, String dbPort, String dbName) {
		m_ddb = new DDB(dbHost, dbPort, dbName);
		
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		m_namespace = null;
		
	}
	
	public Dao2(DNamespace namespace) throws DScabiException {
		if (false == namespace.getType().equals("AppTable")) {
			throw new DScabiException("Namespace type is not AppTable", "DAO.SDE.1");
		}
		m_ddb = new DDB(namespace.getHost(), namespace.getPort(), namespace.getSystemSpecificName());
		
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		m_namespace = namespace;
		
	}

	public Dao2(DMeta meta, String strNamespace) throws IOException, ParseException, DScabiClientException, DScabiException {
		
		DNamespace namespace = meta.getNamespace(strNamespace);
		if (false == namespace.getType().equals("AppTable")) {
			throw new DScabiException("Namespace type is not AppTable", "DAO.SDE.1");
		}
		m_ddb = new DDB(namespace.getHost(), namespace.getPort(), namespace.getSystemSpecificName());
		
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		m_namespace = namespace;

	}
	
	public int close() {
		if (m_ddb != null)
			m_ddb.close();
		m_ddb = null;
		return 0;
		
	}

	public int setDatabase(String dbHost, String dbPort, String dbName) {
		close();
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		m_namespace = null;
		m_ddb = null;
		
		m_ddb = new DDB(dbHost, dbPort, dbName);
		return 0;
	}

	public int setNamespace(DNamespace namespace) throws DScabiException {
		if (false == namespace.getType().equals("AppTable")) {
			close();
			
			m_tableName = null;
			m_firstTime = true;
			m_fieldNames = null;
			m_table = null;
			m_namespace = null;
			m_ddb = null;

			throw new DScabiException("Namespace type is not AppTable", "DAO.SDE.1");
		}
		close();
		
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		m_namespace = null;
		m_ddb = null;

		m_ddb = new DDB(namespace.getHost(), namespace.getPort(), namespace.getSystemSpecificName());
		m_namespace = namespace;
		return 0;
	}
	
	public int setNamespace(String strNamespace) throws DScabiException, IOException {
		DNamespace namespace = new DNamespace(strNamespace);
		if (false == namespace.getType().equals("AppTable")) {
			close();
			
			m_tableName = null;
			m_firstTime = true;
			m_fieldNames = null;
			m_table = null;
			m_namespace = null;
			m_ddb = null;

			throw new DScabiException("Namespace type is not AppTable", "DAO.SDE.1");
		}
		close();
		
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		m_namespace = null;
		m_ddb = null;

		m_ddb = new DDB(namespace.getHost(), namespace.getPort(), namespace.getSystemSpecificName());
		m_namespace = namespace;
		return 0;
	}

	public int setTableName(String tableName) throws DScabiException {
		m_tableName = null;
		m_firstTime = true;
		m_fieldNames = null;
		m_table = null;
		if (false == m_ddb.tableExists(tableName)) {
			throw new DScabiException("Table name doesn't exist : " + tableName, "DDO.STN.1");
		}
		m_table = m_ddb.getTable(tableName);
		m_tableName = tableName;
		return 0;
	}

	public ArrayList<String> fieldNames() throws DScabiException {
		if (null == m_tableName) {
			throw new DScabiException("Table name is null", "DDO.FNS.1");
		}
		if (null == m_table) {
			throw new DScabiException("Table is null", "DDO.FNS.2");
		}
		log.debug("fieldNames() firstTime is {}", m_firstTime);
		if (m_table.count() <= 0) {
			log.debug("fieldNames() table.count() is {}", m_table.count());
			return null;
		}
		if (m_firstTime) {
			m_fieldNames = m_table.fieldNamesUsingFindOne();
			m_firstTime = false;
			return m_fieldNames;

		}
		return m_fieldNames;
	}

	public DTable getTable() {
		return m_table;
	}

	public boolean isEmpty(ArrayList<String> fieldList) {
		if (null == fieldList)
			return true;
		if (fieldList.isEmpty())
			return true;
		return false;
	}
	
	public int insertRow(String jsonRow, String jsonCheck) throws DScabiException, IOException {
		return m_table.insertRow(jsonRow, jsonCheck);
	}
	
	public String executeQuery(String jsonQuery) throws DScabiException, IOException {
		return m_table.executeQuery(jsonQuery);
	}
	
	public DResultSet executeQueryCursorResult(String jsonQuery) throws IOException, DScabiException {
		return m_table.executeQueryCursorResult(jsonQuery);
	}
	
	public long executeUpdate(String jsonUpdate, String jsonWhere) throws IOException, DScabiException {
		return m_table.executeUpdate(jsonUpdate, jsonWhere);
	}
	
	public long executeRemove(String jsonWhere) throws IOException, DScabiException {
		return m_table.executeRemove(jsonWhere);
	}
	
	public int getResultCount(String jsonResult) throws IOException {
		DMJson djson = new DMJson(jsonResult);
		String s = djson.getString("Count");
		return Integer.parseInt(s);
	}
	
}
