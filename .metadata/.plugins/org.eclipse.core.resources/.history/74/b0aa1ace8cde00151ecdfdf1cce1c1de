/**
 * @author Dilshad Mustafa
 * (c) Dilshad Mustafa
 * All Rights Reserved.
 * @version 1.0
 * @since 07-Feb-2016
 * File Name : ComputePool.java
 */
package com.dilmus.dilshad.scabi.client;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.apache.http.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dilmus.dilshad.scabi.common.DScabiException;

/**
 * @author Dilshad Mustafa
 *
 */
public class Compute implements Runnable {

	private final Logger log = LoggerFactory.getLogger(Compute.class);
	private ExecutorService m_threadPool = null;
	private Meta m_meta = null;
	private int m_commandID = 1;
	private HashMap<String, ComputeConfig> m_commandMap = null;
	private String m_jsonInput = null;
	private HashMap<String, String> m_outputMap = null;
	private int m_maxSplit = 1;
	private int m_maxRetry = 0;
	private int m_maxThreads = 1;
	private int m_splitTotal = 0;
	private ComputeConfig m_config = null;
	private boolean m_isPerformInProgress = false;
	private boolean m_crunListReady = false;
	private boolean m_futureListReady = false;

	private List<ComputeConfig> m_cconfigList = null;
	private List<ComputeRun> m_crunList = null;
	private List<ComputeSync> m_csyncList = null;
	
	private List<Future<?>> m_futureList = null;
	private HashMap<Future<?>, ComputeRun> m_futureCRunMap = null;
	// Not use private List<ComputeSync> m_csyncWorkingList = null;
	// Not used private List<ComputeRun> m_crunForRetryList = null;
	
	public List<ComputeConfig> getCConfigList() {
		return m_cconfigList;
	}
	
	public List<ComputeRun> getCRunList() {
		return m_crunList;
	}
	
	public List<ComputeSync> getCSyncList() {
		return m_csyncList;
	}
	
	public ExecutorService getExecutorService() {
		return m_threadPool;
	}
	
	public Compute(Meta meta) {
		
		m_meta = meta;
		m_commandMap = new HashMap<String, ComputeConfig>();
		
		m_maxSplit = 1;
		m_maxRetry = 0;
		m_maxThreads = 1;
		m_splitTotal = 0;
		
		m_cconfigList = new ArrayList<ComputeConfig>();
		m_crunList = new ArrayList<ComputeRun>();
		m_csyncList = new ArrayList<ComputeSync>();
		
		m_futureList = new ArrayList<Future<?>>();
		m_futureCRunMap = new HashMap<Future<?>, ComputeRun>();
		// Not used m_crunForRetryList = null;
	}
	
	public int initialize() throws InterruptedException {
		//m_threadPool.shutdown();
		m_threadPool.shutdownNow();
		m_threadPool.awaitTermination(10, TimeUnit.MINUTES);
		m_threadPool = null;

		m_commandID = 1;
		m_commandMap.clear();
		m_jsonInput = null;
		m_outputMap = null;
		
		m_maxSplit = 1;
		m_maxRetry = 0;
		m_maxThreads = 1;
		m_splitTotal = 0;
		
		m_config = null;

		m_isPerformInProgress = false;
		m_crunListReady = false;
		m_futureListReady = false;

		synchronized (this) {
			
		m_cconfigList.clear();
		// m_crunList is not thread safe and RetryMonitor is also using it
		// So it is cleared after thread pool shutdown
		m_crunList.clear();
		m_csyncList.clear();
				
		m_futureList.clear();
		m_futureCRunMap.clear();
		}
		
		return 0;
	}
	
	public int close() {
		m_threadPool.shutdown();
		m_threadPool = null;
		return 0;
	}
	
	public Compute executeCode(String code) throws DScabiException {
		if (m_isPerformInProgress) {
			throw new DScabiException("Perform already in progress", "COE.EOT.1");
		}
		if (m_config != null) {
			m_config.setInput(m_jsonInput);
			m_config.setOutput(m_outputMap);
			m_config.setMaxSplit(m_maxSplit);
			m_config.setMaxRetry(m_maxRetry);
			m_commandMap.put("" + m_commandID, m_config);
			m_commandID++;
			
			m_splitTotal = m_splitTotal + m_maxSplit;

			m_maxSplit = 1;
			m_maxRetry = 0;

			m_cconfigList.add(m_config);
			
			m_config = null;
		}
		m_config = new ComputeConfig(code);
		
		return this;
	}

	public Compute executeClass(Class<? extends ComputeUnit> cls) throws DScabiException {
		if (m_isPerformInProgress) {
			throw new DScabiException("Perform already in progress", "COE.EOT.1");
		}
		if (m_config != null) {
			m_config.setInput(m_jsonInput);
			m_config.setOutput(m_outputMap);
			m_config.setMaxSplit(m_maxSplit);
			m_config.setMaxRetry(m_maxRetry);
			m_commandMap.put("" + m_commandID, m_config);
			m_commandID++;
			
			m_splitTotal = m_splitTotal + m_maxSplit;

			m_maxSplit = 1;
			m_maxRetry = 0;

			m_cconfigList.add(m_config);
			
			m_config = null;
		}
		m_config = new ComputeConfig(cls);
		
		return this;
	}

	
	public Compute executeObject(ComputeUnit unit) throws DScabiException {
		if (m_isPerformInProgress) {
			throw new DScabiException("Perform already in progress", "COE.EOT.1");
		}
		if (m_config != null) {
			m_config.setInput(m_jsonInput);
			m_config.setOutput(m_outputMap);
			m_config.setMaxSplit(m_maxSplit);
			m_config.setMaxRetry(m_maxRetry);
			m_commandMap.put("" + m_commandID, m_config);
			m_commandID++;
			
			m_splitTotal = m_splitTotal + m_maxSplit;

			m_maxSplit = 1;
			m_maxRetry = 0;

			m_cconfigList.add(m_config);
			
			m_config = null;
		}
		m_config = new ComputeConfig(unit);
		
		return this;
	}

	public Compute input(String jsonInput) {
		m_jsonInput = jsonInput;
		return this;
	}
	
	public Compute input(Properties propertyInput) {
		//m_jsonInput = jsonInput;
		return this;
	}

	public Compute input(HashMap<String, String> mapInput) {
		//m_jsonInput = jsonInput;
		return this;
	}
	
	public Compute output(HashMap<String, String> outputMap) {
		// outputTo()
		m_outputMap = outputMap;
		return this;
	}

	public Compute maxSplit(int maxSplit) {
		m_maxSplit = maxSplit;
		return this;
	}
	
	public Compute maxRetry(int maxRetry) {
		m_maxRetry = maxRetry;
		return this;
	}
	
	public Compute maxThreads(int maxThreads) {
		m_maxThreads = maxThreads;
		return this;
	}
	
	/* Not used. Previous working version without retry mechanism
	public void run() {
		//ComputeSync csync = m_meta.getCompute();
		//ComputeSync csynca[] = m_meta.getComputeMany(m_commandID);
		ComputeSync csynca[];
		try {
			csynca = m_meta.getComputeMany(2);
		} catch (ParseException | IOException | ScabiClientException e) {
			
			e.printStackTrace();
			return;
		}
		
        for (ComputeSync csync : csynca) {
        	log.debug("Compute is {}", csync);
        }

        Set<String> st = m_commandMap.keySet();
        int k = 0;
        for (String key : st) {
	        //if (k >= csynca.length)
	        //	k = 0;
        	ComputeConfig config = m_commandMap.get(key);
			int maxSplit = config.getMaxSplit();
			log.debug("maxSplit : {}", maxSplit);
        	for (int i = 0; i < maxSplit; i++) {
        		log.debug("Inside split for loop");
        		if (k >= csynca.length)
    	        	k = 0;
            	ComputeRun cr = new ComputeRun(); 
            	cr.setConfig(config);
            	synchronized(csynca[k]) {
	            	csynca[k].setTU(maxSplit);
	            	csynca[k].setSU(i + 1);
            	}
            	cr.setComputeSync(csynca[k]);
    			k++;
    			m_threadPool.execute(cr);
        	}
        }
		
	}
	*/
	
	public synchronized int addToFutureList(Future<?> f) {
		m_futureList.add(f);
		return 0;
	}
	
	public synchronized Future<?> getFromFutureList(int index) {
		return m_futureList.get(index);
	}

	
	public synchronized int putFutureCRunMap(Future<?> f, ComputeRun crun) {
		m_futureCRunMap.put(f, crun);
		return 0;
	}
	
	public synchronized ComputeRun getFutureCRunMap(Future<?> f) {
		return m_futureCRunMap.get(f);
	}

	public void run() {
		
		ComputeSync csynca[];
		try {
			// TODO m_meta.getComputeMany(m_splitTotal);
			csynca = m_meta.getComputeMany(2);
		} catch (ParseException | IOException | ScabiClientException e) {
			e.printStackTrace();
			return;
		}
        for (ComputeSync csync : csynca) {
        	log.debug("Compute is {}", csync);
        	m_csyncList.add(csync);
        }
        
        Set<String> st = m_commandMap.keySet();
        int k = 0;
        for (String key : st) {
        	ComputeConfig config = m_commandMap.get(key);
			int maxSplit = config.getMaxSplit();
			log.debug("maxSplit : {}", maxSplit);
        	for (int i = 0; i < maxSplit; i++) {
        		log.debug("Inside split for loop");
        		if (k >= csynca.length)
    	        	k = 0;
            	ComputeRun crun = new ComputeRun(); 
            	m_crunList.add(crun);
            	crun.setConfig(config);
            	crun.setTU(maxSplit);
            	crun.setSU(i + 1);
            	crun.setMaxRetry(config.getMaxRetry());
            	/* Not used
            	synchronized(csynca[k]) {
	            	csynca[k].setTU(maxSplit);
	            	csynca[k].setSU(i + 1);
            	}
            	*/
            	crun.setComputeSync(csynca[k]);
    			k++;
    			
        	}
        }
        log.debug("run() m_crunList.size() : {}", m_crunList.size()); 
        m_crunListReady = true;
        
        // works m_threadPool.execute(new RetryMonitor(this, m_meta));
        Future<?> g = m_threadPool.submit(new RetryMonitor(this, m_meta));
        m_futureList.add(g);
        
        for (ComputeRun crun : m_crunList) {
        	// works m_threadPool.execute(crun);
     	
        	Future<?> f = m_threadPool.submit(crun);
        	//Future<ComputeRun> f = m_threadPool.submit(crun, crun);
        	
        	addToFutureList(f);
        	putFutureCRunMap(f, crun);
        	
        }
        m_futureListReady = true;
        
        /* Bug in code below
        // Using csync index to get from m_crunList!! If csync.length is 2 then it will always take first two entries
        // from m_crunList!!
        k = 0;
        for (String key : st) {
        	ComputeConfig config = m_commandMap.get(key);
			int maxSplit = config.getMaxSplit();
			log.debug("maxSplit : {}", maxSplit);
        	for (int i = 0; i < maxSplit; i++) {
        		log.debug("Inside split for loop");
        		if (k >= csynca.length)
    	        	k = 0;
            	ComputeRun crun = m_crunList.get(k); 
    			k++;
    			m_threadPool.execute(crun);
        	}
        }
         */
        
        
        
	}

	/* Not used. Previous attempt at retry mechanism within same thread
	public int handleRetry() throws ParseException, IOException, ScabiClientException {
		int fcTotal = 0;
		int csyncWorkingTotal = 0;
		m_csyncWorkingList = new ArrayList<ComputeSync>();
		m_csyncWorkingList.addAll(m_csyncList);
		
		for (ComputeConfig cconfig : m_cconfigList) {
			HashMap<String, Integer> mapRetry = cconfig.getFailedSplitRetryMap();
			Set<String> st = mapRetry.keySet();
			for (String splitno : st) {
				Integer retriesTillNow = mapRetry.get(splitno);
				if (retriesTillNow < cconfig.getMaxRetry() && false == cconfig.getSplitStatus(Integer.parseInt(splitno)))
					fcTotal = fcTotal + 1;
			}
		}
		if (0 == fcTotal) {
			log.debug("fcTotal : {}", fcTotal);
			return 0;
		}
		for (ComputeSync csync : m_csyncWorkingList) {
			if (csync.isFaulty()) {
				m_csyncWorkingList.remove(csync);
			}
		}
		csyncWorkingTotal = m_csyncWorkingList.size();
		
		if (fcTotal > csyncWorkingTotal) {
			ComputeSync csynca[] = m_meta.getComputeMany(fcTotal - csyncWorkingTotal);
			for (ComputeSync csync : csynca) {
				m_csyncWorkingList.add(csync);
			}
		}
		int k = 0;
		for (ComputeConfig cconfig : m_cconfigList) {
			HashMap<String, Integer> mapRetry = cconfig.getFailedSplitRetryMap();
			Set<String> st = mapRetry.keySet();
			for (String splitno : st) {
				Integer retriesTillNow = mapRetry.get(splitno);
				if (retriesTillNow < cconfig.getMaxRetry() && false == cconfig.getSplitStatus(Integer.parseInt(splitno))) {
	        		log.debug("Inside split for loop");
	        		if (k >= m_csyncWorkingList.size())
	    	        	k = 0;
	            	ComputeRun crun = new ComputeRun(); 
	            	m_crunForRetryList.add(crun);
	            	crun.setConfig(cconfig);
	            	ComputeSync csync = m_csyncWorkingList.get(k);
	            	int maxSplit = cconfig.getMaxSplit();
	            	synchronized(csync) {
		            	csync.setTU(maxSplit);
		            	csync.setSU(Integer.parseInt(splitno));
	            	}
	            	crun.setComputeSync(csync);
	    			k++;
	    			m_threadPool.execute(crun);
				}
			}
		}
		
		boolean check = true;
		while(check) {
			for (ComputeRun crun : m_crunForRetryList) {
				if (false == crun.isDone()) {
					check = false;
					break;
				}
			}
			if (check)
				break;	
			check = true;
		}
		return 0;
	}
	*/
	
	public boolean finish() throws DScabiException, ExecutionException, InterruptedException {
		if (false == m_isPerformInProgress)
			return true;
		log.debug("finish() m_splitTotal : {}", m_splitTotal);
		log.debug("finish() m_crunList.size() : {}", m_crunList.size());
		log.debug("finish() m_crunListReady : {}", m_crunListReady);
		
		/*
		log.debug("finish() m_futureList.size() : {}", m_futureList.size());
		log.debug("finish() m_futureListReady : {}", m_futureListReady);
		int gap = 0;
		while (false == m_futureListReady) {
			// TODO log.debug from this point onwards doesn't work if we don't use log.debug here!!!
			if (0 == gap % 1000000000) // reduce this number if needed to make it print atleast once
				log.debug("finish() m_futureListReady : {}", m_futureListReady);
			gap++;
		}
		log.debug("finish() m_futureList.size() : {}", m_futureList.size());

		Throwable t = null;
		for (Future<?> f : m_futureList) {
			log.debug("finish() Inside get() loop");
			try {
				if (f.get() != null)
					throw new DScabiException("f.get() != null", "COE.FIH.1");
			} catch (CancellationException ce) {
	            //t = ce;
	            throw ce;
	        } catch (ExecutionException ee) {
	            //t = ee.getCause();
	            throw ee;
	        } catch (InterruptedException ie) {
	            //Thread.currentThread().interrupt(); // ignore/reset
	            throw ie;
	        }
		}
		log.debug("finish() Exiting finish()");
		initialize();
		return true;
		*/
		
		
		int gap = 0;
		while (false == m_crunListReady) {
			// TODO log.debug from this point onwards doesn't work if we don't use log.debug here!!!
			if (0 == gap % 1000000000) // reduce this number if needed to make it print atleast once
				log.debug("finish() m_crunListReady : {}", m_crunListReady);
			gap++;
		}
		log.debug("finish() m_crunList.size() : {}", m_crunList.size());

		boolean check = true;
		while(check) {
			for (ComputeRun crun : m_crunList) {
				if (crun.getRetriesTillNow() < crun.getMaxRetry() && true == crun.isError() && true == crun.isDone() ) {
					check = false;
					break;
				} else if (false == crun.isDone()) {
					check = false;
					break;
				} else if (true == crun.isRetrySubmitted()) {
					check = false;
					break;
				} else if (true == crun.isExecutionError()) {
					return true;
				}
				
			}
			if (check)
				break;	
			check = true;
		}
		log.debug("finish() Exiting finish()");
		initialize();
		return true;
		
	}
	
	public boolean finish(long checkTillNanoSec) throws InterruptedException {
		if (false == m_isPerformInProgress)
			return true;
		long time1 = System.nanoTime();
		log.debug("finish(nanosec) m_splitTotal : {}", m_splitTotal);
		log.debug("finish(nanosec) m_crunList.size() : {}", m_crunList.size());
		log.debug("finish(nanosec) m_crunListReady : {}", m_crunListReady);
		int gap = 0;
		while (false == m_crunListReady) {
			// TODO log.debug from this point onwards doesn't work if we don't use log.debug here!!!
			if (0 == gap % 1000000000) // reduce this number if needed to make it print atleast once
				log.debug("finish(nanosec) m_crunListReady : {}", m_crunListReady);
			gap++; // this is just for the log.debug issue mentioned above
			if (System.nanoTime() - time1 >= checkTillNanoSec)
				return false;
		}
		log.debug("finish(nanosec) m_crunList.size() : {}", m_crunList.size());

		boolean check = true;
		while(check) {
			for (ComputeRun crun : m_crunList) {
				if (crun.getRetriesTillNow() < crun.getMaxRetry() && true == crun.isError() && true == crun.isDone() ) {
					check = false;
					break;
				} else if (false == crun.isDone()) {
					check = false;
					break;
				} else if (true == crun.isRetrySubmitted()) {
					check = false;
					break;
				}
				
			}
			if (check)
				break;	
			check = true;
			if (System.nanoTime() - time1 >= checkTillNanoSec)
				return false;

		}
		log.debug("finish(nanosec) Exiting finish()");
		initialize();
		return true;
	}

	public boolean isDone() {
		if (false == m_isPerformInProgress)
			return true;
		log.debug("isDone() m_splitTotal : {}", m_splitTotal);
		log.debug("isDone() m_crunList.size() : {}", m_crunList.size());
		log.debug("isDone() m_crunListReady : {}", m_crunListReady);
		if (false == m_crunListReady)
			return false;
		log.debug("isDone() m_crunList.size() : {}", m_crunList.size());

		boolean check = true;
			for (ComputeRun crun : m_crunList) {
				if (crun.getRetriesTillNow() < crun.getMaxRetry() && true == crun.isError() && true == crun.isDone() ) {
					check = false;
					break;
				} else if (false == crun.isDone()) {
					check = false;
					break;
				} else if (true == crun.isRetrySubmitted()) {
					check = false;
					break;
				}
				
			}
		log.debug("isDone() Exiting finish()");
		return check;
	}

	
	public Compute perform() throws ParseException, IOException, ScabiClientException, DScabiException {
		if (m_config != null) {
			m_config.setInput(m_jsonInput);
			m_config.setOutput(m_outputMap);
			m_config.setMaxSplit(m_maxSplit);
			m_config.setMaxRetry(m_maxRetry);
			m_commandMap.put("" + m_commandID, m_config);
			m_commandID++;
						
			m_splitTotal = m_splitTotal + m_maxSplit;

			m_maxSplit = 1;
			m_maxRetry = 0;

			m_cconfigList.add(m_config);
			
			m_config = null;
		}

		if (1 == m_commandID) {
			log.debug("No commands are added");
			return this;
		}
		if (false == m_isPerformInProgress)
			m_isPerformInProgress = true;
		else {
			throw new DScabiException("Perform already in progress", "COE.PEM.1");
		}
		log.debug("perform() m_splitTotal : {}", m_splitTotal);
		log.debug("perform() m_maxThreads : {}", m_maxThreads);
		if (1 == m_maxThreads) {
			long usedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
			log.debug("perform() usedMemory : {}", usedMemory);
			long freeMemory = Runtime.getRuntime().maxMemory() - usedMemory;
			log.debug("perform() freeMemory : {}", freeMemory);
			
			long noOfThreads = freeMemory / (1024 * 1024); // Assuming 1 Thread consumes 1MB memory
			log.debug("perform() noOfThreads : {}", noOfThreads);
			
			if (m_splitTotal < noOfThreads) {
				// works m_threadPool = Executors.newFixedThreadPool(m_splitTotal + 2); // +1 to include thread for this class run() method
				m_threadPool = new DThreadPoolExecutor(
						m_splitTotal + 2, m_splitTotal + 2, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), this);
				
				log.debug("threads created : {}", m_splitTotal + 2);
			} else {
				// works m_threadPool = Executors.newFixedThreadPool((int)noOfThreads);
				m_threadPool = new DThreadPoolExecutor(
						(int)noOfThreads, (int)noOfThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), this);
			
				log.debug("threads created : {}", noOfThreads);
			}
			// Not used m_threadPool = Executors.newFixedThreadPool(m_splitTotal + 2); // +1 to include thread for this class run() method
			// Not used log.debug("threads created : {}", m_splitTotal + 2);
		}
		else
		{
			// works m_threadPool = Executors.newFixedThreadPool(m_maxThreads);
			m_threadPool = new DThreadPoolExecutor(
					m_maxThreads, m_maxThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), this);
			
			log.debug("perform() threads created : {}", m_maxThreads);
		}
		/* Not used
		else if (m_splitTotal < m_maxThreads) {
			m_threadPool = Executors.newFixedThreadPool(m_splitTotal + 2); // +1 to include thread for this class run() method
			log.debug("threads created : {}", m_splitTotal + 2);
		}
		else {
			m_threadPool = Executors.newFixedThreadPool(m_maxThreads);
			log.debug("threads created : {}", m_maxThreads);
		}
		*/
				
		// works m_threadPool.execute(this);
        		
		Future<?> f = m_threadPool.submit(this);
		m_futureList.add(f);
		return this;
	}
	
}
