/**
 * @author Dilshad Mustafa
 * (c) Dilshad Mustafa
 * All Rights Reserved.
 * @version 1.0
 * @since 21-Jan-2016
 * File Name : CNSMain.java
 */

package com.dilmus.dilshad.scabi.cs;

//import static spark.Spark.*;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.core.Application;

import org.eclipse.jetty.server.Connector;
import org.eclipse.jetty.server.Handler;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.server.handler.HandlerList;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;
import org.eclipse.jetty.util.thread.QueuedThreadPool;
import org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import bsh.EvalError;
import bsh.Interpreter;
import bsh.ParseException;
import bsh.TargetError;
//import spark.Request;
//import spark.Response;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.CtNewMethod;
import javassist.LoaderClassPath;
import javassist.Modifier;

import com.dilmus.dilshad.scabi.client.DComputeUnit;
import com.dilmus.dilshad.scabi.client.Dao;
import com.dilmus.dilshad.scabi.client.DaoHelper;
import com.dilmus.dilshad.scabi.client.Dson;
import com.dilmus.dilshad.scabi.common.DDB;
import com.dilmus.dilshad.scabi.common.DMClassLoader;
import com.dilmus.dilshad.scabi.common.DMJson;
import com.dilmus.dilshad.scabi.common.DMJsonHelper;
import com.dilmus.dilshad.scabi.common.DMNamespace;
import com.dilmus.dilshad.scabi.common.DMNamespaceHelper;
import com.dilmus.dilshad.scabi.common.DScabiException;
import com.dilmus.dilshad.scabi.ms.DMComputeMeta;
import com.dilmus.dilshad.scabi.ms.DMComputeMetaHelper;
import com.dilmus.dilshad.scabi.ms.MNSMain;
import com.dilmus.dilshad.scabi.common.DMUtil;
import com.dilmus.dilshad.scabi.common.DMComputeTemplate;
import com.mongodb.DBCollection;

// for BigInteger
import java.math.*;

/**
 * @author Dilshad Mustafa
 *
 */

@Path("/")
public class ComputeServer extends Application {

	private static Logger log = null;
	
	private Set<Class<?>> st = new HashSet<Class<?>>();
	 
	public ComputeServer() throws DScabiException {
		//classesSet.add(ApplicationCommandResource.class);
		st.add(ComputeServer.class);

	}
	 
	public Set<Class<?>> getClasses() {
		return st;
	}
	
   @GET
   @Path("/")
   public String get() { return "hello world from CNS"; }

   @POST
   @Path("/")
   public String post(String s) { return "hello world from CNS"; }

   
   @POST
   @Path("/Compute/Execute/BshCode")
   public String executeCode(String request) throws IOException {
       log.debug("executeCode() request : {}", request);

       //Interpreter i = new Interpreter();
       String s = null;
       try {
       	
    	   DMJson djson = new DMJson(request);
           
    	   DMClassLoader dcl = new DMClassLoader();
    	   if(false == djson.contains("AddJars")) {
    		   log.debug("executeCode() Information only : No additional jars to load. AddJars are not provided.");
    	   } else {
    		   log.debug("executeCode() AddJars are provided");
    		   loadAddJars(dcl, djson);
  				
    		   //=====Debugging purpose only==========
    		   //log.debug("executeCode() Going to load class TestNew");
    		   //Class<?> testNew = dcl.loadClass("test.TestNew");
    		   //log.debug("executeCode() Loaded class TestNew with name : {}", testNew.getName());
    		   //=====================================
    	   }
    	   
    	   log.debug("executeCode() TotalComputeUnit : {}", djson.getTU());
    	   log.debug("executeCode() SplitComputeUnit : {}", djson.getCU());
    	   log.debug("executeCode() JsonInput : {}", djson.getString("JsonInput"));
	  		
    	   Dson dson1 = new Dson("TotalComputeUnit", djson.getString("TotalComputeUnit"));
    	   Dson dson2 = dson1.add("SplitComputeUnit", djson.getString("SplitComputeUnit"));
    	   Dson dson3 = dson2.add("JsonInput", djson.getString("JsonInput"));
           
    	   DaoHelper ddaohelp = new DaoHelper("localhost", "27017", "MetaDB");
    	   
           Interpreter i = new Interpreter();
           
           // Not working i.setClassLoader(Thread.currentThread().getContextClassLoader());
           // Not working i.setClassLoader(ClassLoader.getSystemClassLoader());
           i.setClassLoader(dcl);
           

           i.set("jsonInput", dson3);
           i.eval("import com.mongodb.*");
           i.eval("import com.dilmus.dilshad.scabi.common.*");
           i.eval("import com.dilmus.dilshad.scabi.client.*");
           
           String code = null;
           code = djson.getString("BshSource");
           log.debug("executeCode() code : {}", code);
           String pcode = DMUtil.preprocess(code);
           log.debug("executeCode() pcode  : {}", pcode);
           s = (String) i.eval(pcode);

       }
       catch ( TargetError e ) {
    	   //s = e.toString();
    	   return DMJson.error(DMUtil.serverErrMsg(e));
       } catch ( ParseException e ) {
    	   //s = e.toString();
    	   return DMJson.error(DMUtil.serverErrMsg(e));
       } catch ( EvalError e ) {
    	   //s = e.toString();
    	   return DMJson.error(DMUtil.serverErrMsg(e));
       } catch (Error | RuntimeException e) {
    	   return DMJson.error(DMUtil.serverErrMsg(e));
       } catch (Exception e) {
    	   return DMJson.error(DMUtil.serverErrMsg(e));
       } catch (Throwable e) {
    	   return DMJson.error(DMUtil.serverErrMsg(e));
       }
       
       return DMJson.result(s);
   	
   }

   /* Not used
   public String computeExecute(String request) {
	   try {
		   return executeCode(request);   
	   } catch(Exception e) {
		   return e.toString();
	   }
   
   }
	*/
   
   @POST
   @Path("/Compute/Execute/Class")
   public String computeExecuteClass(String request) {
	   System.gc();
	   DMClassLoader dcl = null;
	   try {

		   DMJson djson = new DMJson(request);
		   
		   String hexStr = djson.getString("ClassBytes");
		   //log.debug("computeExecuteClass() Hex string is : {}", hexStr);
		   String className = djson.getString("ClassName");
		   log.debug("computeExecuteClass() className is : {}", className);
		  	
		   byte b2[] = DMUtil.toBytesFromHexStr(hexStr);

		   /* Previously used working code
		   dcl = new DClassLoader();
		   Class<?> df = dcl.findClass(className, b2);
		   ComputeUnit cuu = (ComputeUnit) df.newInstance();

		   log.debug("computeExecuteClass() TotalComputeUnit : {}", djson.getTU());
		   log.debug("computeExecuteClass() SplitComputeUnit : {}", djson.getSU());
		   log.debug("computeExecuteClass() JsonInput : {}", djson.getString("JsonInput"));
		   
		   Dson dson1 = new Dson("TotalComputeUnit", djson.getString("TotalComputeUnit"));
		   Dson dson2 = dson1.add("SplitComputeUnit", djson.getString("SplitComputeUnit"));
		   Dson dson3 = dson2.add("JsonInput", djson.getString("JsonInput"));
		   
		   String result = cuu.compute(dson3);
		   dcl = null;
		   return DJson.result(result);
		   // return "" + result;
		   // return null; // returns HTTP/1.1 204 No Content
		   */
		   
		   	// Not used ClassLoader cl = ClassLoader.getSystemClassLoader();
	  		boolean proceed = false;
	  		DComputeUnit cuu = null;
	  		try {
	  			dcl = new DMClassLoader();
	  			Class<?> df = dcl.findClass(className, b2);
	  			
	  			if(false == djson.contains("AddJars")) {
	  				log.debug("computeExecuteClass() Information only : No additional jars to load. AddJars are not provided.");
	  			} else {
	  				log.debug("computeExecuteClass() AddJars are provided");
	  				loadAddJars(dcl, djson);
	  				
	  				//=====Debugging purpose only==========
	  				//log.debug("computeExecuteClass() Going to load class TestNew");
	  				//Class<?> testNew = dcl.loadClass("test.TestNew");
	  				//log.debug("computeExecuteClass() Loaded class TestNew with name : {}", testNew.getName());
	  				//=====================================
	  			}
	  			
		  		cuu = (DComputeUnit) df.newInstance();
		  		proceed = true;
	  		} catch (SecurityException | InstantiationException | IllegalAccessException e) {
	  			//e.printStackTrace();
	  			proceed = false;
	  		} catch (ClassCastException e) {
	  			return DMJson.error(DMUtil.serverErrMsg(e));
	  		}
	  		
	  		log.debug("computeExecuteClass() TotalComputeUnit : {}", djson.getTU());
	  		log.debug("computeExecuteClass() SplitComputeUnit : {}", djson.getCU());
	  		log.debug("computeExecuteClass() JsonInput : {}", djson.getString("JsonInput"));
			   
	  		Dson dson1 = new Dson("TotalComputeUnit", djson.getString("TotalComputeUnit"));
	  		Dson dson2 = dson1.add("SplitComputeUnit", djson.getString("SplitComputeUnit"));
	  		Dson dson3 = dson2.add("JsonInput", djson.getString("JsonInput"));

	  		if (proceed) {
	  			log.debug("computeExecuteClass() ComputeUnit cast is working ok for this object");
		  		String result = cuu.compute(dson3);
		  		dcl = null;
		  		log.debug("computeExecuteClass() result : {}", result);
		  		return DMJson.result(result);
		  		
	  		} else {
	  			log.debug("computeExecuteClass() ComputeUnit cast is not working for this object. So proceeding with Class copy.");
	  			InputStream fis = new ByteArrayInputStream(b2);
		
				ClassPool pool = ClassPool.getDefault();
				pool.appendSystemPath();
				// Reference pool.appendClassPath(new LoaderClassPath(_extraLoader));
				pool.insertClassPath(new LoaderClassPath(Thread.currentThread().getContextClassLoader()));
				// Reference pool.importPackage("com.dilmus.dilshad.scabi.client.Dson");
				CtClass cr = pool.makeClass(fis);
		  		cr.setModifiers(cr.getModifiers() | Modifier.PUBLIC);
		  		log.debug("computeExecuteClass() modifiers : {}", cr.getModifiers());
		  		
		  		// Reference CtClass ct = pool.getAndRename("com.dilmus.test.ComputeTemplate", "CT" + System.nanoTime());
		  		log.debug("computeExecuteClass() DMComputeTemplate.class.getCanonicalName() : {}", DMComputeTemplate.class.getCanonicalName());
		  		CtClass ct = pool.getAndRename(DMComputeTemplate.class.getCanonicalName(), "CT" + System.nanoTime());
		  		   
			    CtMethod amethods[] = cr.getDeclaredMethods();
			    for (CtMethod amethod : amethods) {
			    	CtMethod bmethod = CtNewMethod.copy(amethod, ct, null);
			    	
			    	// OR
			    	//CtMethod bmethod = new CtMethod(pool.get(String.class.getCanonicalName()), "compute", new CtClass[] {pool.get(Dson.class.getCanonicalName())}, ct);
			    	//bmethod.setBody(amethod, null);
			    	//bmethod.setModifiers(bmethod.getModifiers() | Modifier.PUBLIC);
			    	// OR
			    	//CtMethod bmethod = CtMethod.make(amethod.getMethodInfo(), ct);
			    	
			    	ct.addMethod(bmethod);
			    }
			    
			    CtField afields[] = cr.getDeclaredFields();
			    for (CtField afield : afields) {
			    	CtField bfield = new CtField(afield, ct);
				    ct.addField(bfield);
			    }
			    
			    // Notes : Anonymous class can not define constructor. So no need to copy constructor
			    
		  		Class<?> df2 = ct.toClass();
		  		Object ob = df2.newInstance();
		  		Method m = df2.getMethod("compute", Dson.class);
		
		 		String result = (String) m.invoke(ob, dson3);
		
		 		// Release CtClass from ClassPool
		 		cr.detach();
		 		ct.detach();
		 		pool = null;
		 		dcl = null;
		 		
		  		log.debug("computeExecuteClass() result : {}", result);
		  		return DMJson.result(result);
	  		}
	   
	   	} catch (Error | RuntimeException e) {
	   		dcl = null;
	   		System.gc();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	} catch(Exception e) {
	   		dcl = null;
	   		System.gc();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	} catch(Throwable e) {
	   		dcl = null;
	   		System.gc();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	}
   
   }

   @POST
   @Path("/Compute/Execute/ClassFromObject")
   public String computeExecuteFromObject(String request) {
	   System.gc();
	   DMClassLoader dcl = null;
	   try {
		   DMJson djson = new DMJson(request);
		   
		   String hexStr = djson.getString("ClassBytes");
		   //log.debug("computeExecuteFromObject() Hex string is : {}", hexStr);
		   String className = djson.getString("ClassName");
		   log.debug("computeExecuteFromObject() className is : {}", className);
		  	
		   byte b2[] = DMUtil.toBytesFromHexStr(hexStr);
		   log.debug("computeExecuteFromObject() to bytes  : {}", b2.toString());
		   /* for debugging
	  	   for (int i = 0; i < b.length; i++) {
	  			//log.debug("computeExecuteFromObject() b : {}, b2 : {}", b[i], b2[i]);
	  			if (b[i] != b2[i]) {
	  				log.debug("computeExecuteFromObject() b and b2 are not same");
	  				break;
	  			}
	  		}
	  		log.debug("computeExecuteFromObject() b and b2 are same");
		    */
	  		// Not used ClassLoader cl = ClassLoader.getSystemClassLoader() ;
	  		boolean proceed = false;
	  		DComputeUnit cuu = null;
	  		try {
	  			dcl = new DMClassLoader();
	  			Class<?> df = dcl.findClass(className, b2);
	  			
	  			if(false == djson.contains("AddJars")) {
	  				log.debug("computeExecuteFromObject() Information only : No additional jars to load. AddJars are not provided.");
	  			} else {
	  				log.debug("computeExecuteFromObject() AddJars are provided");
	  				loadAddJars(dcl, djson);
	  				
	  				//=====Debugging purpose only==========
	  				log.debug("computeExecuteFromObject() Going to load class TestNew");
	  				//Class<?> testNew = dcl.loadClass("test.TestNew");
	  				//log.debug("computeExecuteFromObject() Loaded class TestNew with name : {}", testNew.getName());
	  				Class<?> testNew = dcl.loadClass("test.TestNew");
	  				log.debug("computeExecuteFromObject() Loaded class TestNew with name : {}", testNew.getName());

	  				//=====================================
	  			}
	  			
		  		cuu = (DComputeUnit) df.newInstance();
		  		proceed = true;
	  		} catch (SecurityException | InstantiationException | IllegalAccessException e) {
	  			// e.printStackTrace();
	  			proceed = false;
	  		} catch (ClassCastException e) {
	  			return DMJson.error(DMUtil.serverErrMsg(e));
	  		}
	  		
	  		log.debug("computeExecuteFromObject() TotalComputeUnit : {}", djson.getTU());
	  		log.debug("computeExecuteFromObject() SplitComputeUnit : {}", djson.getCU());
	  		log.debug("computeExecuteFromObject() JsonInput : {}", djson.getString("JsonInput"));
			   
	  		Dson dson1 = new Dson("TotalComputeUnit", djson.getString("TotalComputeUnit"));
	  		Dson dson2 = dson1.add("SplitComputeUnit", djson.getString("SplitComputeUnit"));
	  		Dson dson3 = dson2.add("JsonInput", djson.getString("JsonInput"));
	  		
	  		if (proceed) {
	  			log.debug("computeExecuteFromObject() ComputeUnit cast is working ok for this object");
		  		String result = cuu.compute(dson3);
		  		dcl = null;
		  		log.debug("computeExecuteFromObject() result : {}", result);
		  		return DMJson.result(result);
		  		
	  		} else {
	  			log.debug("computeExecuteFromObject() ComputeUnit cast is not working for this object. So proceeding with Class copy.");
	  			InputStream fis = new ByteArrayInputStream(b2);
		
				ClassPool pool = ClassPool.getDefault();
				pool.appendSystemPath();
				// Reference pool.appendClassPath(new LoaderClassPath(_extraLoader));
				pool.insertClassPath(new LoaderClassPath(Thread.currentThread().getContextClassLoader()));
				// Reference pool.importPackage("com.dilmus.dilshad.scabi.client.Dson");
				CtClass cr = pool.makeClass(fis);
		  		cr.setModifiers(cr.getModifiers() | Modifier.PUBLIC);
		  		log.debug("computeExecuteFromObject() modifiers : {}", cr.getModifiers());
		  		
		  		// Reference CtClass ct = pool.getAndRename("com.dilmus.test.ComputeTemplate", "CT" + System.nanoTime());
		  		log.debug("computeExecuteFromObject() DMComputeTemplate.class.getCanonicalName() : {}", DMComputeTemplate.class.getCanonicalName());
		  		CtClass ct = pool.getAndRename(DMComputeTemplate.class.getCanonicalName(), "CT" + System.nanoTime());
		  		
		  		// Reference
		  		// CtMethod amethod = cr.getDeclaredMethod("compute");
			    // CtMethod bmethod = CtNewMethod.copy(amethod, ct, null);
			    // log.debug("computeExecuteFromObject() bmethod.getDeclaringClass() : {}", bmethod.getDeclaringClass()); 
			    // ct.addMethod(bmethod);
			    
			    CtMethod amethods[] = cr.getDeclaredMethods();
			    for (CtMethod amethod : amethods) {
			    	CtMethod bmethod = CtNewMethod.copy(amethod, ct, null);
			    	
			    	// OR
			    	//CtMethod bmethod = new CtMethod(pool.get(String.class.getCanonicalName()), "compute", new CtClass[] {pool.get(Dson.class.getCanonicalName())}, ct);
			    	//bmethod.setBody(amethod, null);
			    	//bmethod.setModifiers(bmethod.getModifiers() | Modifier.PUBLIC);
			    	// OR
			    	//CtMethod bmethod = CtMethod.make(amethod.getMethodInfo(), ct);
			    	
			    	ct.addMethod(bmethod);
			    }
			    
			    CtField afields[] = cr.getDeclaredFields();
			    for (CtField afield : afields) {
			    	CtField bfield = new CtField(afield, ct);
				    ct.addField(bfield);
			    }
			    
			    // Notes : Anonymous class can not define constructor. So no need to copy constructor
			    
		  		Class<?> df2 = ct.toClass();
		  		if (null == df2)
		  			System.out.println("null == df2");

		  		Object ob = df2.newInstance();
		  		if (null == ob)
		  			System.out.println("null == ob");

		  		Method m = df2.getMethod("compute", Dson.class);
		  		if (null == m)
		  			System.out.println("null == m");

		 		String result = (String) m.invoke(ob, dson3);
		
		 		// Release CtClass from ClassPool
		 		/*
		 		java.lang.NullPointerException
		 		at java.util.Hashtable.put(Hashtable.java:459)
		 		at javassist.ClassPool.cacheCtClass(ClassPool.java:258)
		 		at javassist.CtClass.detach(CtClass.java:1350)
		 		at com.dilmus.dilshad.scabi.cns.ComputeServer.computeExecuteFromObject(ComputeServer.java:411)
		 		*/
		 		//cr.detach();
		 		//ct.detach();
		 		pool = null;
		 		dcl = null;
		 		
		  		log.debug("computeExecuteFromObject() result : {}", result);
		  		return DMJson.result(result);
		  		// // // return "" + result;
	  		}
	  		// // // return null; // returns HTTP/1.1 204 No Content
		   
	   } catch (Error | RuntimeException e) {
		   dcl = null;
		   System.gc();
		   //e.printStackTrace();
		   return DMJson.error(DMUtil.serverErrMsg(e));
	   	} catch(Exception e) {
	   		dcl = null;
	   		System.gc();
	   		//e.printStackTrace();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	} catch(Throwable e) {
	   		dcl = null;
	   		System.gc();
	   		//e.printStackTrace();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	}
   
   }
   
   @POST
   @Path("/Compute/Execute/ClassNameInJar")
   public String computeExecuteClassNameInJar(String request) {
	   System.gc();
	   DMClassLoader dmcl = null;
	   try {

		   DMJson djson = new DMJson(request);
		   
		   String hexStr = djson.getString("JarBytes");
		   //log.debug("computeExecuteClass() Hex string is : {}", hexStr);
		   String classNameInJar = djson.getString("ClassNameInJar");
		   log.debug("computeExecuteClassNameInJar() classNameInJar is : {}", classNameInJar);
		  	
		   byte b2[] = DMUtil.toBytesFromHexStr(hexStr);
  		
		   log.debug("computeExecuteClassNameInJar() TotalComputeUnit : {}", djson.getTU());
		   log.debug("computeExecuteClassNameInJar() SplitComputeUnit : {}", djson.getCU());
		   log.debug("computeExecuteClassNameInJar() JsonInput : {}", djson.getString("JsonInput"));
			   
		   Dson dson1 = new Dson("TotalComputeUnit", djson.getString("TotalComputeUnit"));
		   Dson dson2 = dson1.add("SplitComputeUnit", djson.getString("SplitComputeUnit"));
		   Dson dson3 = dson2.add("JsonInput", djson.getString("JsonInput"));
			   
		   DComputeUnit cuu = null;
				
		   dmcl = new DMClassLoader();
		   String s = dmcl.loadJarAndSearchClass(b2, classNameInJar);
		   if (null == s) {
			   log.debug("computeExecuteClassNameInJar() No match found for given class name : {}", classNameInJar);
			   return DMJson.error("No match found for given class name : " + classNameInJar);
		   } else {
			   log.debug("computeExecuteClassNameInJar() found first matching name for given class name : {}, matching class name : {}", classNameInJar, s);
		   }
		   Class<?> df = dmcl.loadClass(s);
 			
		   if(false == djson.contains("AddJars")) {
			   log.debug("computeExecuteClassNameInJar() Information only : No additional jars to load. AddJars are not provided.");
		   } else {
			   log.debug("computeExecuteClassNameInJar() AddJars are provided");
			   loadAddJars(dmcl, djson);
  				
			   //=====Debugging purpose only==========
			   //log.debug("Going to load class TestNew");
			   //Class<?> testNew = dcl.loadClass("test.TestNew");
			   //log.debug("Loaded class TestNew with name : {}", testNew.getName());
			   //=====================================
		   }
		   
		   cuu = (DComputeUnit) df.newInstance();
		   log.debug("computeExecuteClassNameInJar() Going to invoke method");
		   Dson dson = new Dson("input", "1");
		   String result = cuu.compute(dson3);
		   log.debug("computeExecuteClassNameInJar result : {}", result);
		   
		   dmcl = null;
		   System.gc();
		   
		   return DMJson.result("" + result);
 		} catch (SecurityException | InstantiationException | IllegalAccessException e) {
 			dmcl = null;
 			System.gc();
 			e.printStackTrace();
 			return DMJson.error(DMUtil.serverErrMsg(e));
  		} catch (ClassCastException e) {
 			dmcl = null;
 			System.gc();
 			e.printStackTrace();
 			return DMJson.error(DMUtil.serverErrMsg(e));
 		} catch (Error | RuntimeException e) {
 			dmcl = null;
 			System.gc();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	} catch(Exception e) {
 			dmcl = null;
 			System.gc();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	} catch(Throwable e) {
 			dmcl = null;
 			System.gc();
	   		return DMJson.error(DMUtil.serverErrMsg(e));
	   	}
   
   }

   public int loadAddJars(DMClassLoader dmcl, DMJson djson) throws IOException, DScabiException {
	   if (false == djson.contains("AddJars"))
		   throw new DScabiException("AddJars key not found in input json", "CSR.LAJ.1");

	   String jsonStrAddJars = djson.getString("AddJars");
	   DMJson djsonAddJars = new DMJson(jsonStrAddJars);
	   Set<String> st = djsonAddJars.keySet();
	   
	   for (String s : st) {
		   log.debug("loadAddJars() loading jar no.{}", s); 
		   String hexStr = djsonAddJars.getString(s);
		   byte b2[] = DMUtil.toBytesFromHexStr(hexStr);
		   dmcl.loadJar(b2);
	   }
	   return 0;
	   
   }
   public static void main(String[] args) throws Exception 
   {
	   int port = 0;
	   String metaHost = null;
	   String metaPort = null;
	   
	   if (3 == args.length) {
		   port = Integer.parseInt(args[0]);
		   metaHost = args[1];
		   metaPort = args[2];
		   System.out.println("Port : " + port);
		   System.out.println("metaHost : " + metaHost);
		   System.out.println("metaPort : " + metaPort);
	   } else {
		   System.out.println("3 arguments should be supplied. Exiting.");
		   return;
	   }
	   
       System.setProperty("org.slf4j.simpleLogger.showDateTime", "true");
       System.setProperty("org.slf4j.simpleLogger.showThreadName", "true");
       System.setProperty("org.slf4j.simpleLogger.levelInBrackets", "true");       
       System.setProperty("org.slf4j.simpleLogger.dateTimeFormat", "yyyy-MM-dd HH:mm:ss:SSS Z");
       System.setProperty("org.slf4j.simpleLogger.defaultLogLevel", "debug");		
       System.setProperty("org.slf4j.simpleLogger.showLogName", "true");		
       //System.setProperty("org.slf4j.simplelogger.defaultlog", "debug");
   	   //System.setProperty(org.slf4j.impl.SimpleLogger.DEFAULT_LOG_LEVEL_KEY, "DEBUG");
 		
       System.setProperty("org.dilmus.dilshad.scabi.Meta.Host", "localhost");
       System.setProperty("org.dilmus.dilshad.scabi.Meta.Port", "4567");
       System.setProperty("org.dilmus.dilshad.scabi.Meta.FailOver.Host", "localhost");
       System.setProperty("org.dilmus.dilshad.scabi.Meta.FailOver.Port", "4567");
 		
       final Logger log = LoggerFactory.getLogger(ComputeServer.class);
       ComputeServer.log = log;

       //metaHost = System.getProperty("org.dilmus.scabi.Meta.Host");
       //metaPort = System.getProperty("org.dilmus.scabi.Meta.Port");
       /* works
       ServletHolder sh = new ServletHolder(HttpServletDispatcher.class);
       sh.setInitParameter("javax.ws.rs.Application", ComputeServer.class.getCanonicalName()); 
       try {
       //Server server = new Server(4568);
       Server server = new Server(port);
       ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
       context.setContextPath("/");
       server.setHandler(context);
       context.addServlet(sh, "/*");
       server.start();
       } catch (Exception e) {
    	   log.debug("Exception : {}", e);
    	   System.exit(0);
       }
       */
       //===============================
       ServletHolder sh = new ServletHolder(HttpServletDispatcher.class);
       sh.setInitParameter("javax.ws.rs.Application", ComputeServer.class.getCanonicalName()); 
       try {
       //Server server = new Server(4568);
    	   QueuedThreadPool q = new QueuedThreadPool();
    	   q.setMinThreads(5);
    	   q.setMaxThreads(5);
    	   //Error ComputeServer exits q.setDaemon(true);
    	   q.setIdleTimeout(60000);
      	   
    	   Server server = new Server(q);
       
    	   ServerConnector sc = new ServerConnector(server);
    	   sc.setIdleTimeout(60000);
    	   sc.setPort(port);
       
    	   ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
    	   context.setContextPath("/");
    	   server.setHandler(context);
    	   context.addServlet(sh, "/*");
    	   
    	   server.addConnector(sc);
    	   server.start();
       } catch (Exception e) {
    	   log.debug("Exception : {}", e);
    	   System.exit(0);
       }

       
       //================================
       log.debug("ComputeServer started");
   }

   	/* uses Spark API
   	public static void main2(String[] args) {
        System.setProperty("org.slf4j.simpleLogger.showDateTime", "true");
        System.setProperty("org.slf4j.simpleLogger.showThreadName", "true");
        System.setProperty("org.slf4j.simpleLogger.levelInBrackets", "true");       
        System.setProperty("org.slf4j.simpleLogger.dateTimeFormat", "yyyy-MM-dd HH:mm:ss:SSS Z");
  		System.setProperty("org.slf4j.simpleLogger.defaultLogLevel", "debug");		
  		System.setProperty("org.slf4j.simpleLogger.showLogName", "true");		
  		//System.setProperty("org.slf4j.simplelogger.defaultlog", "debug");
    	//System.setProperty(org.slf4j.impl.SimpleLogger.DEFAULT_LOG_LEVEL_KEY, "DEBUG");
  		
  		System.setProperty("org.dilmus.dilshad.scabi.Meta.Host", "localhost");
  		System.setProperty("org.dilmus.dilshad.scabi.Meta.Port", "4567");
  		System.setProperty("org.dilmus.dilshad.scabi.Meta.FailOver.Host", "localhost");
  		System.setProperty("org.dilmus.dilshad.scabi.Meta.FailOver.Port", "4567");
  		
  		final Logger log = LoggerFactory.getLogger(CNSMain.class);
  		CNSMain.log = log;
  		
        port(4568);

        String metaHost = System.getProperty("org.dilmus.scabi.Meta.Host");
        String metaPort = System.getProperty("org.dilmus.scabi.Meta.Port");
        
        get("/hellocns", (req, res) -> "Hello World CNS4");
        System.out.println("from jar file Hello world CNS4");
        
        post("/Compute/Execute", (req, res) -> {
        	return test(req, res);
        });
        
	}
    */
    
   	/* Reference
    public static String executeCode(String request) throws IOException {
    	
        Interpreter i = new Interpreter();  // Construct an interpreter
        //String bshString = "s = 140; return \"\" + s;";
		//InputStream fis = new ByteArrayInputStream(Charset.forName("UTF-16").encode(bshString).array());
        //InputStreamReader ireader = new InputStreamReader(fis);
        // FileReader reader = new FileReader(fis);
        String s = null;
        String s2 = null;
        try {
        	// Gives Parsing Exception String s = (String) i.eval( ireader );
        	// works s = (String) i.eval( bshString );
        	// i.set("res", res); // works!!
        	// works s = (String) i.eval("return \"\" + 155;");
        	
        	DJson djson = new DJson(request);
            DaoHelper ddaohelp = new DaoHelper("localhost", "27017", "MetaDB");
            // works DJsonHelper json = new DJsonHelper(); 
            
	  		log.debug("executeCode() TotalComputeUnit : {}", djson.getTU());
	  		log.debug("executeCode() SplitComputeUnit : {}", djson.getSU());
	  		log.debug("executeCode() JsonInput : {}", djson.getString("JsonInput"));
			   
	  		Dson dson1 = new Dson("TotalComputeUnit", djson.getString("TotalComputeUnit"));
	  		Dson dson2 = dson1.add("SplitComputeUnit", djson.getString("SplitComputeUnit"));
	  		Dson dson3 = dson2.add("JsonInput", djson.getString("JsonInput"));
            
            i.set("database", ddaohelp);
            // works i.set("json", json);
            i.set("dson", dson3);
            i.eval("import com.mongodb.*");
            i.eval("import com.dilmus.dilshad.scabi.common.*");

            // works
            //       String action ="DBCollection dbc = database.getTable(\"ComputeMetaDataTable\");" +
            //				"ArrayList st = database.fieldNames(dbc);" +
            //				"return st.toString();";

            // works
            //      String action ="DDAO dao = database.createDAO();" +
    		//		"dao.setTableName(\"ComputeMetaDataTable\"); ArrayList st = dao.fieldNames();" +
    		//		"return st.toString();";
             
            // works
            //      String action ="DDAO dao = database.createDAO();" +
    		//		"dao.setTableName(\"ComputeMetaDataTable\");" +
    		//		"String jsonQuery = \"{ \\\"Status\\\":\\\"Available\\\" }\";" +
    		//   		"String jsonResult = dao.executeQuery(jsonQuery);" +
    		//		"return jsonResult;";
             
            // works
            
            //String action ="DDAO dao = database.createDAO();" +
    		//		"dao.setTableName(\"ComputeMetaDataTable\");" +
    		//		"String jsonQuery = json.json(\"{ <<<Status>>> : <<<Available>>> }\");" +
            //  		"String jsonResult = dao.executeQuery(jsonQuery);" +
    		//		"return jsonResult;";
        	
        	//s2 = (String) i.eval(action);

            log.debug("request : {}", request);

            String a2 = null;
            a2 = djson.getString("BshSource");
            log.debug("a2 : {}", a2);
            String a3 = DUtil.preprocess(a2);
            log.debug("a3 : {}", a3);
            s2 = (String) i.eval(a3);

        	// works
    		//FileReader fis2 = new FileReader("/home/anees/workspace/testdata/in/testbsh1.bsh");
        	//s2 = (String) i.eval(fis2);
			
        }
        catch ( TargetError e ) {
        	s = e.toString();
        	return s;
        } catch ( ParseException e ) {
        	s = e.toString();
        	return s;
        } catch ( EvalError e ) {
        	s = e.toString();
        	return s;
        }
        
        
        //DDAOHelper ddaohelp = new DDAOHelper("localhost", "27017");
        //DBCollection dbc = ddaohelp.getTable("ComputeMetaDataTable");
        //ArrayList st = ddaohelp.fieldNames(dbc);
        
        //works return "Sending back to client, bsh result " + s + " Body from Req : " + req.body() + " Field names : " + st.toString();
        //works return "Sending back to client, bsh result " + s + " Body from Req : " + req.body() + " Field names from bsh result : " + s2;
    	//works return s2;
        return "Sending back to client " + request + " s2 : " + s2 + " s : " + s;
   	
    }
    */
	
}
