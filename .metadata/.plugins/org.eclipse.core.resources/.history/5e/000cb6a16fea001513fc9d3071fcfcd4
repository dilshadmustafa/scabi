package com.dilmus.dilshad.test;

import com.dilmus.dilshad.scabi.client.DComputeUnit;
import com.dilmus.dilshad.scabi.client.DMeta;
import com.dilmus.dilshad.scabi.client.Dson;
import com.dilmus.dilshad.scabi.client.async.DComputeAsync;

import java.util.HashMap;
import java.util.Set;

/**
 * @author Dilshad Mustafa
 * (c) Dilshad Mustafa
 * All Rights Reserved.
 * @version 1.0
 * @since 06-Mar-2016
 * File Name : Example1.java
 */

/**
 * @author Dilshad Mustafa
 *
 */
public class Test1 {

	   public static void main(String[] args) throws Exception {

		   /* The examples below use DComputeAsync class which internally uses asynchronous non-blocking network I/O
		    * and can submit very large number of split jobs / Compute Units
		    */
	    	System.out.println("Example1");

	    	DMeta meta = new DMeta("localhost", "5000");
	     	DComputeAsync c = new DComputeAsync(meta);

	     	// Using executeClass() method to submit Compute Units for execution in the Cluster
	     	Dson jsonInput = new Dson();
	     	jsonInput.add("NumberToCheck", "993960000099397");
	     	// Other numbers to try : 20 digits 12764787846358441471, 30 digits 671998030559713968361666935769
	     	HashMap<String, String> out1 = new HashMap<String, String>();
	     	System.out.println("Submitting Compute Units through executeClass() to Cluster for execution");
	     	c.executeClass(MyPrimeCheckUnit.class).input(jsonInput).split(5).output(out1);
	     	c.perform();
	     	c.finish();
	     	
	     	// Using executeObject() method to submit Compute Units through object references and objects of Anonymous class
	     	DComputeUnit cu = new DComputeUnit() {
	     		public String compute(Dson jsonInput) {
	     			return "Hello from this Compute Unit CU #" + jsonInput.getCU();
	     		}
	     	};
	     	HashMap<String, String> out2 = new HashMap<String, String>();
	     	System.out.println("Submitting Compute Units through executeObject() to Cluster for execution");
	     	c.executeObject(cu).input(jsonInput).split(3).output(out2);
	     	c.perform();
	     	c.finish();

	     	// Using execudeCode() method to submit java source code chunks for execution in the Cluster
	     	HashMap<String, String> out3 = new HashMap<String, String>();
	     	System.out.println("Submitting Compute Units through executeCode() to Cluster for execution");
	     	c.addJar("/home/anees/self/MyPrimeCheckUnit.jar"); // Add Java libraries, jar files like this
	     	c.executeCode("import MyPrimeCheckUnit;" +
	     				  "cu = new MyPrimeCheckUnit();" +
	     			      "return cu.compute(jsonInput);");
	     	c.input(jsonInput).split(1).output(out3).perform();
	     	c.finish();
	     	
	     	// Using executeJar() method to submit Compute Units for execution in the Cluster
	     	HashMap<String, String> out4 = new HashMap<String, String>();
	     	System.out.println("Submitting Compute Units through executeJar() to Cluster for execution");
	     	c.executeJar("/home/anees/self/MyPrimeCheckUnit.jar", "MyPrimeCheckUnit");
	     	c.input(jsonInput).split(2).output(out4).perform();
	     	c.finish();

	     	if (out1.isEmpty())
	     		System.out.println("out1 is empty");
	     	Set<String> st1 = out1.keySet();
	     	for (String s : st1) {
	     		System.out.println("out1 for s : " + s + " value : " + out1.get(s));
	     	}

	     	if (out2.isEmpty())
	     		System.out.println("out2 is empty");
	     	Set<String> st2 = out2.keySet();
	     	for (String s : st2) {
	     		System.out.println("out2 for s : " + s + " value : " + out2.get(s));
	     	}
	    	
	        if (out3.isEmpty())
	     		System.out.println("out3 is empty");
	     	Set<String> st3 = out3.keySet();
	     	for (String s : st3) {
	     		System.out.println("out3 for s : " + s + " value : " + out3.get(s));
	     	}
	     	
	        if (out4.isEmpty())
	     		System.out.println("out4 is empty");
	     	Set<String> st4 = out4.keySet();
	     	for (String s : st4) {
	     		System.out.println("out4 for s : " + s + " value : " + out4.get(s));
	     	}
	     	
	     	meta.close();
	   }
}

